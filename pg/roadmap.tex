\documentclass{article}
\usepackage{fullpage}
\usepackage[utf8x]{inputenc}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{autonum}
\usepackage{dsfont}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}





\def\1{{\mathds 1}}
\def\N{\mathbb N}
\def\R{\mathbb R}
\def\={\stackrel{def}{=}}
\def\Xmax{X_{+}}
\def\Xmin{X_{-}}
\newcommand{\suc}[1]{f(#1)}


\begin{document}

Bruno Scherrer, bruno.scherrer@inria.fr, March 22nd, 2022.
~\\

In this short note, I describe a roadmap in order to prove that a parity game can be solved in polynomial time along with an algorithm to do so.


\paragraph{1) Extension of parity game}

The goal is made more precise. Both players, if they lose, want to make the priority of the other player as low as possible. This precisely define an optimal parity. This problem can be reduced to MPG through a Puri like reduction.
Also we want to add a neutral priority (corresponding to 0 in the MPG reduction).

\paragraph{2) Algorithm}

Add the priorities, one by one, starting from the highest.

At each step, identify the set of states that are won with priority d, against neutral states (corresponding to lower parities) and states with higher priorities (but for which we know both player can avoid cycling on them).

At each step, I would say it suffices to run $2n$ steps of VI to find the states that go to a cycle of priority $d$ (A simpler way would be to 1) identify limit cycles with priorities d, states that can't reach states with higher priorities, and then compute the attractor of the current player).


\end{document}
